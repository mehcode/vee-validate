/**
  * vee-validate v4.12.5
  * (c) 2024 Abdelrahman Awad
  * @license MIT
  */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("vee-validate"),require("valibot")):"function"==typeof define&&define.amd?define(["exports","vee-validate","valibot"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).VeeValidateValibot={},e.veeValidate,e.valibot)}(this,(function(e,t,r){"use strict";const n=e=>null!==e&&!!e&&"object"==typeof e&&!Array.isArray(e);function o(e){return Number(e)>=0}function i(e){if(!function(e){return"object"==typeof e&&null!==e}(e)||"[object Object]"!==function(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}(e))return!1;if(null===Object.getPrototypeOf(e))return!0;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function u(e,t){return Object.keys(t).forEach((r=>{if(i(t[r])&&i(e[r]))return e[r]||(e[r]={}),void u(e[r],t[r]);e[r]=t[r]})),e}function s(e,t){e.forEach((e=>{var r;const n=function(e){const t=e.split(".");if(!t.length)return"";let r=String(t[0]);for(let e=1;e<t.length;e++)o(t[e])?r+=`[${t[e]}]`:r+=`.${t[e]}`;return r}((e.path||[]).map((e=>e.key)).join("."));(null===(r=e.issues)||void 0===r?void 0:r.length)&&(s(e.issues.flatMap((e=>e.issues||[])),t),!n)||(t[n]||(t[n]={errors:[],path:n}),t[n].errors.push(e.message))}))}function c(e){return"optional"===e.type}function l(e){return n(e)&&"array"===e.type}function f(e){return n(e)&&"object"===e.type}e.toTypedSchema=function(e){return{__type:"VVTypedSchema",async parse(t){const n=await r.safeParseAsync(e,t);if(n.success)return{value:n.output,errors:[]};const o={};return s(n.issues,o),{errors:Object.values(o)}},cast(t){if(e.async)return t;const o=r.safeParse(e,t);if(o.success)return o.output;const i=r.getDefault(r.optional(e));return n(i)&&n(t)?u(i,t):t},describe(r){if(!r)return{required:!c(e),exists:!0};const n=function(e,r){if(!f(r))return null;if(t.isNotNestedPath(e))return r.entries[t.cleanupNonNestedPath(e)];const n=(e||"").split(/\.|\[(\d+)\]/).filter(Boolean);let i=r;for(let e=0;e<=n.length;e++){const t=n[e];if(!t||!i)return i;f(i)?i=i.entries[t]||null:o(t)&&l(i)&&(i=i.item)}return null}(r,e);return n?{required:!c(n),exists:!0}:{required:!1,exists:!1}}}}}));